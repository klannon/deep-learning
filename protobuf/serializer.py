"""
serializer.py is designed to be used iff you did not properly serialize
all of the information abour your experiment when you ran it in the
first place.  You should edit this file to properly describe the
experiment you ran, and then run

>> python serializer.py LOG_FILE_NAME

where LOG_FILE_NAME is the name of the log file generated by Keras
containing the information about the results of your training.
"""
from experiment_pb2 import *
import sys, os

import unittest

class SerializerTestCase(unittest.TestCase):
    def setUp(self):
        os.mkdir("test")
        os.chdir("test")
        test_file = open("test.log", "w")
        test_file.write("Epoch 1/200\n"
                        "21s - loss: 0.5758 - acc: 0.6995\n"
                        "Epoch 2/200\n"
                        "21s - loss: 0.5649 - acc: 0.7091\n"
                        "Epoch 3/200\n"
                        "21s - loss: 0.5605 - acc: 0.7132\n"
                        "Epoch 4/200\n"
                        "21s - loss: 0.5579 - acc: 0.7157\n"
                        "Epoch 5/200\n"
                        "21s - loss: 0.5560 - acc: 0.7170\n")
        test_file.close()
        self.losses = [0.5758,
                       0.5649,
                       0.5605,
                       0.5579,
                       0.5560]
        self.times = [21,
                      21,
                      21,
                      21,
                      21]
        self.accuracies = [0.6995,
                           0.7091,
                           0.7132,
                           0.7157,
                           0.7170]
        
    def test_parse_log_file(self):
        self.assertEqual(parse_log_file("test.log"),
                         (self.times, self.losses, self.accuracies))

    def test_create_epochs_from_data(self):
        create_epochs_from_data(self.times, self.losses, self.accuracies)

    def test_add_epochs_to_experiment(self):
        exp = Experiment()
        exp = add_epochs_to_experiment(exp, self.times, self.losses,
                                       self.accuracies)
        epochs = create_epochs_from_data(self.times, self.losses,
                                         self.accuracies)
        self.assertEqual(exp.results[:], epochs) # need [:] because
        # the type of exp.results is google.protobuf.internal.
        # containers.RepeatedCompositeFieldContainer while the type of
        # epochs is list. [:] gives exp.results in list form so equality
        # can be tested

    def tearDown(self):
        import shutil
        os.chdir("..")
        shutil.rmtree("test")

def parse_log_file(log_file_name):
    """
    Parses useful information out of a log file
    parse_log_file takes the name of a log file (log_file_name)
    formatted by Keras, figures out if it exists, and returns lists
    containing the training time (in seconds), the value of the loss
    function, and the training accuracy

    Parameters
    ----------
    log_file_name : name of a log file formatted by Keras.
    If the log file isn't real and you were trying to fool me, the
    script will quit.

    Returns
    -------
    times : list of epoch times (in seconds)

    losses : list of values of the loss function

    accuracies : list of the training accuracies
    
    Notes
    -----
    Element 0 in the returned lists is always the value of the
    parameter for the first epoch
    """
    # check that the provided log file is a real file
    f = None
    try:
        f = open(log_file_name, "r")
    except IOError:
        print ("ERROR -- " + log_file_name + " is not a valid file")
        exit(-1)
        
    times = []
    losses = []
    accuracies = []

    while(True):
        line = f.readline()
        if(line == ""):
            break
        if("Epoch" in line):
            data = f.readline().strip().split(" - ")
            # print(data)
            time = data[0].split("s")[0]
            times.append(float(time))
            # print(time)
            loss = data[1].split("loss: ")[1]
            losses.append(float(loss))
            # print(loss)
            accuracy = data[2].split("acc: ")[1]
            accuracies.append(float(accuracy))

    return(times, losses, accuracies)



def create_epochs_from_data(times, losses, train_accuracies,
                            test_accuracies=None):
    """
    Creates a list of experiment_pb2.Epoch() objects
    create_epochs_from_data takes lists of times, losses, and
    accuracies and generates a list of experiment_pb2.Epoch() objects
    that can be added to experiment_pb2.Experiment().results

    Parameters
    ----------
    times : list of times (seconds) that epochs took

    losses : list of the value of the loss function after each epoch

    train_accuracies : list of the training accuracy for each epoch

    test_accuracies : list of the testing accuracy for each epoch
    This isn't currently implemented in our Keras code, so I left it
    as optional for now

    Returns
    -------
    epochs : list of experiment_pb2.Epoch() objects
    """
    num_epochs = len(times) # times, losses, and accuracies should
    # all be the same length, so my choice of times is arbitrary
    epochs = []
    for i in range(num_epochs):
        a = Epoch()
        a.num_seconds = times[i]
        a.loss = losses[i]
        a.train_accuracy = train_accuracies[i]
        epochs.append(a)
    return epochs
        
def add_epochs_to_experiment(experiment, times, losses,
                             train_accuracies):
    num_epochs = len(times) # times, losses, and accuracies should
    # all be the same length, so my choice of times is arbitrary
    for i in range(num_epochs):
        a = experiment.results.add()
        a.num_seconds = times[i]
        a.loss = losses[i]
        a.train_accuracy = train_accuracies[i]
    return experiment


if __name__ == "__main__":
    # uncomment the next 2 lines to run the tests
    # suite = unittest.TestLoader().loadTestsFromTestCase(SerializerTestCase)
    # unittest.TextTestRunner(verbosity=2).run(suite)

    
    # check that the right number of arguments were provided
    if len(sys.argv) != 2:
        print ("ERROR -- Usage:" + sys.argv[0] + " LOG_FILE_NAME")

    log_file_path = sys.argv[1]
    (times, losses, accuracies) = parse_log_file(log_file_path)
    
    exp = Experiment()
    exp = add_epochs_to_experiment(exp, times, losses, accuracies)

    log_file_name_extension = os.path.split(log_file_path)[1]
    log_file_name = log_file_name_extension.split(".")[0]
    output_file_name = ("%s.experiment"
                        % log_file_name)
    print output_file_name
    os.chdir("../data/OSU_TTBAR/")
    f = open(output_file_name, "wb")
    f.write(exp.SerializeToString())
    f.close()
