# ---------------------------------------------------------------------
# Loads the run_3v data generated by OSU
#
# Authors: Colin Dablain, Matthew Drnevich
#
# This script borrows heavily from Peter Sadowski's
# https://github.com/klannon/higgs-susy/blob/master/physics.py
# ---------------------------------------------------------------------

from pylearn2.datasets import dense_design_matrix
import numpy as np

class PHYSICS(dense_design_matrix.DenseDesignMatrix):

    def __init__(self, data_X=None, data_Y=None, benchmark='', which_set='?'):
        self.args = locals()

        # Initialize the superclass. DenseDesignMatrix
        if data_X:
            super(PHYSICS, self).__init__(X=data_X, y=data_Y)

    def load_data(self, data_X, data_Y=None, benchmark='', which_set='?'):

        # Initialize the superclass. DenseDesignMatrix
        super(PHYSICS, self).__init__(X=data_X, y=data_Y)

        print 'Data loaded: {} ({})'.format(benchmark, which_set)

    def load_from_file(self, path_to_X, path_to_Y, benchmark='', which_set='?'):

        X = np.load(path_to_X)
        Y = np.load(path_to_Y)

        self.load_data(X, Y, benchmark, which_set)

    def standardize(self, X):
        """
        Standardize each feature:
        1) If data contains negative values, we assume its either normally or uniformly distributed, center, and standardize.
        2) elseif data has large values, we set mean to 1.
        """
        for j in range(X.shape[1]):
            vec = X[:, j]
            if np.min(vec) < 0:
                # Assume data is Gaussian or uniform -- center and standardize.
                vec = vec - np.mean(vec)
                vec = vec / np.std(vec)
            elif np.max(vec) > 1.0:
                # Assume data is exponential -- just set mean to 1.
                vec = vec / np.mean(vec)
            X[:,j] = vec
        return X
