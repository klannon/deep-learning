# ---------------------------------------------------------------------
# Trains a neural network on the run_3v data generated by OSU
#
# Authors: Colin Dablain, Matthew Drnevich
#
# This script borrows heavily from Peter Sadowski's
# https://github.com/klannon/higgs-susy/blob/master/physics.py
# ---------------------------------------------------------------------

from pylearn2.datasets import dense_design_matrix
from pylearn2.datasets import control
from pylearn2.utils import serial
import os
import numpy as np
import pickle as pkl
import csv
import os

def PHYSICS(pathToTrainValidData,
            pathToTestData,
            trainFraction,
            *args,
            **kwargs):

    benchmark_1 = pathToTrainValidData.split(os.sep)[-1].split('.')[0] # Returns the name of the file without its extension
    benchmark_2 = pathToTestData.split(os.sep)[-1].split('.')[0]

    train, valid = csv.getData(pathToTrainValidData, trainFraction, benchmark=benchmark_1, **kwargs)
    test = csv.getData(pathToTestData, 0, benchmark=benchmark_2, **kwargs)

    return (_PHYSICS(train, 'train', benchmark_1),
            _PHYSICS(valid, 'valid', benchmark_1),
            _PHYSICS(test, 'test', benchmark_2))

class _PHYSICS(dense_design_matrix.DenseDesignMatrix):
    def __init__(self,
                 data,
                 which_set='?',
                 benchmark=''):

        self.args = locals()

        # Need to allocate two arrays X (inputs) and y (targets)
        print 'Data loaded: {} ({})'.format(benchmark, which_set)

        # Initialize the superclass. DenseDesignMatrix
        super(_PHYSICS, self).__init__(X=data['data'], y=data['labels'])
        
    def standardize(self, X):
        """
        Standardize each feature:
        1) If data contains negative values, we assume its either normally or uniformly distributed, center, and standardize.
        2) elseif data has large values, we set mean to 1.
        """
        for j in range(X.shape[1]):
            vec = X[:, j]
            if np.min(vec) < 0:
                # Assume data is Gaussian or uniform -- center and standardize.
                vec = vec - np.mean(vec)
                vec = vec / np.std(vec)
            elif np.max(vec) > 1.0:
                # Assume data is exponential -- just set mean to 1.
                vec = vec / np.mean(vec)
            X[:,j] = vec
        return X

if __name__ == '__main__':
    PHYSICS('../OSUtorch/train_all_3v_ttbar_wjet.txt', '../OSUtorch/test_all_3v_ttbar_wjet.txt', 0.8, numLabels=2)